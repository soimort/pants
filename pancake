#!/usr/bin/env ruby
# coding: utf-8

# Author: Mort Yao <soi@mort.ninja>
# License:
#   This is free and unencumbered software released into the public domain.
"""
Pancake <https://github.com/soimort/soimort/tree/pancake>

Dependencies:
- ruby     >= 2.0
  - listen >= 3.0
- pandoc   >= 1.15
"""
require 'yaml'
require 'json'
require 'open3'
require 'webrick'
require 'listen'

# Common settings
PANDOC = 'pandoc'
METADATA_EXT = ['.yaml', '.yml']
SOURCE_EXT   = ['.markdown', '.md', '.md.txt']
IGNORED_EXT  = ['.html', '.htm', '.pdf']
SETTINGS = {
  'preload' => true,
  'meta'    => [],
  'source'  => [],
}

# Logging utilities
def i(x)   puts "\33[36m#{x}\33[0m"   end
def ok(x)  puts "\33[32m#{x}\33[0m"   end
def w(x)   puts "\33[33m#{x}\33[0m"   end
def e(x)   puts "\33[33;1m#{x}\33[0m" end
def wtf(x) puts "\33[31;1m#{x}\33[0m" end

# Main module
module Pancake

  def self.escape(str)
    str.gsub(/[ "'*?]/) { |s| '\\' + s }
  end

  def self.get_file_list(name, exclude = nil)
    return [] if exclude && exclude.match(File.basename(name))
    return [name] unless File.directory? name
    Dir.glob(File.join(name, '*')).inject [] do |files, file|
      files + get_file_list(file, exclude)
    end
  end

  def self.main(target, extra_opts = [])
    opts = []

    # find all relevant paths
    root_path = File.expand_path('.')
    target_path = if File.directory? target
                    File.expand_path(target)
                  else
                    File.expand_path('..', target)
                  end
    paths = []
    paths << t = target_path
    until t == root_path do
      paths << t = File.expand_path('..', t)
    end
    # paths.reverse! - don't

    # find preloadable metadata files and source files
    metadata_files = SETTINGS['meta']
    source_files = SETTINGS['source']
    if SETTINGS['preload']
      files = []
      paths.each do |path|
        configs = Dir.glob(File.join(path, '*')).select do |file|
          file[path.length+1..-1].start_with? '_'
        end
        files += configs.inject [] do |files, config|
          files + get_file_list(config)
        end
      end
      metadata_files += files.select do |file|
        METADATA_EXT.include? File.extname(file)
      end
      source_files += files.select do |file|
        SOURCE_EXT.include? File.extname(file)
      end
    end

    # preload metadata
    meta = metadata_files.reverse.inject Hash.new do |meta, metadata_file|
      i "    <#{target}> preloading metadata: " \
        "#{metadata_file[root_path.length+1..-1]}"
      meta.merge! YAML.load_file(metadata_file)
    end

    # generate pandoc options
    # I/O formats
    opts << ['-f',  meta['input-format']] if meta['input-format']
    opts << ['-t',  meta['output-format']] if meta['output-format']
    # template
    opts << ['--template', meta['template']] if meta['template']
    # filter(s)
    [meta['filter'] || meta['filters']].flatten.each do |filter|
      opts << ['--filter', filter]
    end if meta['filter'] || meta['filters']
    # bibliography file
    if meta['source-bibliography'] and
      File.exist?(File.join(target_path, meta['source-bibliography']))
      opts << ['--bibliography',
               File.join(target_path, meta['source-bibliography'])]
    end
    # target (output) file
    opts << ['--output',
             File.join(target_path, meta['target'])] if meta['target']
    # metadata: id
    if meta['source']
      # only when 'source' field is specified
      begin
        id = escape target_path[root_path.length+1..-1]
        opts << ['-M', "id=#{id}"]
      rescue
        i "    <#{target}> top-level generation."
      end
    end
    # misc & raw option(s)
    opts << "--mathjax=#{meta['mathjax']}" if meta['mathjax'] # must use =
    [meta['raw-option'] || meta['raw-options']].flatten.each do |opt|
      opts << opt
    end if meta['raw-option'] || meta['raw-options']
    # extra options
    opts += extra_opts
    # source files (must come before metadata files)
    if meta['source']
      # only when 'source' field is specified
      opts << File.join(target_path, meta['source'])
    else
      opts << target
    end
    opts += source_files
    # metadata files (must come after source files)
    opts += metadata_files
    if meta['source-metadata'] and
      File.exist?(File.join(target_path, meta['source-metadata']))
      opts << File.join(target_path, meta['source-metadata'])
    end

    i "    <#{target}> generating: #{([PANDOC] + opts).flatten.join ' '}"
    unless system(PANDOC, *opts.flatten)
      e "    <#{target}> generating failed."
      # do not exit
    end
  end
end

# Main entry point

if __FILE__ == $0
  real_targets = [] # keep track of real targets
  extra_opts = []   # keep track of extra options
  ARGV.each_index do |arg_no|
    target = ARGV[arg_no]

    if File.exist? target
      # real target
      real_targets << target
      i "[#{arg_no+1}] <#{target}> target processing ..."
      Pancake::main(target, extra_opts)

    elsif target.start_with? '-'
      # extra option
      extra_opts << target
      i "[#{arg_no+1}] '#{target}' extra option added."

    elsif target.start_with? '/'
      # control option
      opt_name, opt_val = target[1..-1].split '='
      case opt_name
      when 'no-preload'
        i "[#{arg_no+1}] '/#{opt_name}' control option found."
        SETTINGS['preload'] = false
      when 'meta'
        i "[#{arg_no+1}] '/#{opt_name}' control option found."
        SETTINGS['meta'] = [opt_val]
      when 'source'
        i "[#{arg_no+1}] '/#{opt_name}' control option found."
        SETTINGS['source'] = [opt_val]
      else
        w "[#{arg_no+1}] '/#{opt_name}' control option not found."
      end

    else
      # phony target
      target_name, target_params_str = target.split ':'
      target_params = {}
      target_params_str.split(',').each do |item|
        param_name, param_val = item.split '='
        target_params[param_name] = param_val || true
      end if target_params_str

      case target_name
      # phony target: all
      when 'all'
        files = Pancake::get_file_list('.', exclude = /_.*/)
        source_files = files.select do |file|
          SOURCE_EXT.include? File.extname(file)
        end.sort
        source_files.each do |source_file|
          Pancake::main(source_file, extra_opts)
        end

      # phony target: server, preview
      when 'server', 'preview'
        last_modified = Time.now
        last_pushed = nil

        if !target_params['watch'] or target_params['watch'].class != String
          listen_path = '.' # true, but no specific watching path
        elsif File.directory? target_params['watch']
          listen_path = target_params['watch']
        elsif File.exist? target_params['watch']
          listen_path = File.expand_path('..', target_params['watch'])
        else
          # invalid watch path
          wtf "[#{arg_no+1}] [#{target_name}] failed: invalid watch path."
          exit 1
        end

        i "[#{arg_no+1}] [#{target_name}] watching: #{listen_path}"
        ignored = IGNORED_EXT.collect do |ext|
          Regexp.new "\\#{ext}$"
        end

        # start listener (watching for changes)
        listener = Listen.to(listen_path, ignore: ignored) do |m, a, r|
          last_modified = Time.now

          w "[#{arg_no+1}] [#{target_name}] modified: #{m}"
          w "[#{arg_no+1}] [#{target_name}] regenerating ..."
          real_targets.each do |real_target|
            Pancake::main(real_target, extra_opts)
          end
          ok "[#{arg_no+1}] [#{target_name}] regenerating completed."
        end
        listener.start # non-blocking

        # set port number (default: 8000)
        if target_params['port']
          target_params['port'] = target_params['port'].to_i
        else
          target_params['port'] = 8000
        end

        # start webrick server
        i "[#{arg_no+1}] [#{target_name}] server started: " \
          "http://localhost:#{target_params['port']}/"
        if target_params['verbose']
          server = WEBrick::HTTPServer.new(
            :Port => target_params['port'],
            :DocumentRoot => Dir::pwd
          )
        else
          server = WEBrick::HTTPServer.new(
            :Port => target_params['port'],
            :DocumentRoot => Dir::pwd,
            :Logger => WEBrick::Log.new(File.open(File::NULL, 'w')),
            :AccessLog => []
          )
        end

        if target_name == 'preview'
          # stream server-sent events

          if real_targets.length != 1
            w "[#{arg_no+1}] [#{target_name}] more than one target files. " +
              "previewing the first one."
          end
          preview_target = real_targets[0]

          server.mount_proc '/__/refresh/' do |req, res|
            res.content_type = 'text/event-stream'

            rd, wr = IO.pipe
            res.body = rd
            res.chunked = true

            data = nil
            if last_modified == last_pushed
              # content unchanged
              data = {
                :updated => false
              }.to_json
            else
              # new content
              i "[#{arg_no+1}] [#{target_name}] (#{Time.now}) content updated."
              opts = []
              # FIXME: opts += extra_opts
              opts << preview_target
              Open3.popen3(PANDOC, *opts.flatten) do |stdin, stdout, stderr, wait_thr|
                content = stdout.read
                data = {
                  :updated => true,
                  :update_time => last_modified.to_s,
                  :content => content
                }.to_json
              end
            end

            begin
              wr << "data: #{data}" << "\r\n" << "\r\n"
            rescue => err
            ensure
              wr.close()
            end

            last_pushed = last_modified
            ok "[#{arg_no+1}] [#{target_name}] (#{Time.now}) event sent." if
              target_params['verbose']
          end
        end

        trap('INT') do
          server.shutdown
          i "[#{arg_no+1}] [#{target_name}] closing server ..."
        end
        server.start

      # invalid target
      else
        wtf "[#{arg_no+1}] [#{target_name}] failed: invalid target."
        exit 1
      end
    end
  end
end
